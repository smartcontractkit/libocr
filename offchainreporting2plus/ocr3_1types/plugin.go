package ocr3_1types

import (
	"context"

	"github.com/smartcontractkit/libocr/offchainreporting2plus/ocr3types"
	"github.com/smartcontractkit/libocr/offchainreporting2plus/types"
)

type ReportsPlusPrecursor []byte

type ReportingPluginFactory[RI any] interface {
	// Creates a new reporting plugin instance. The instance may have
	// associated goroutines or hold system resources, which should be
	// released when its Close() function is called.
	NewReportingPlugin(
		context.Context,
		ocr3types.ReportingPluginConfig,
		BlobBroadcastFetcher,
	) (ReportingPlugin[RI], ReportingPluginInfo, error)
}

type KeyValueReader interface {
	// A return value of nil indicates that the key does not exist.
	Read(key []byte) ([]byte, error)
}

type KeyValueReadWriter interface {
	KeyValueReader
	Write(key []byte, value []byte) error
	Delete(key []byte) error
}

// A ReportingPlugin allows plugging custom logic into the OCR3 protocol. The
// OCR protocol handles cryptography, networking, ensuring that a sufficient
// number of nodes is in agreement about any report, transmitting the report to
// the contract, etc... The ReportingPlugin handles application-specific logic.
// To do so, the ReportingPlugin defines a number of callbacks that are called
// by the OCR protocol logic at certain points in the protocol's execution flow.
// The report generated by the ReportingPlugin must be in a format understood by
// contract that the reports are transmitted to.
//
// We assume that each correct node participating in the protocol instance will
// be running the same ReportingPlugin implementation. However, not all nodes
// may be correct; up to f nodes be faulty in arbitrary ways (aka byzantine
// faults). For example, faulty nodes could be down, have intermittent
// connectivity issues, send garbage messages, or be controlled by an adversary.
//
// For a protocol round where everything is working correctly, follower oracles
// will call Observation, ValidateObservation, ObservationQuorum, StateTransition,
// and Reports. The leader oracle will additionally call Query at the beginning of
// the round. For each report, ShouldAcceptAttestedReport will be called, iff
// the oracle is in the set of transmitters for the report. If
// ShouldAcceptAttestedReport returns true, ShouldTransmitAcceptedReport will be
// called. However, an ReportingPlugin must also correctly handle the case where
// faults occur.
//
// In particular, an ReportingPlugin must deal with cases where:
//
// - only a subset of the functions on the ReportingPlugin are invoked for a
// given round
//
// - the observation returned by Observation is not included in the list of
// AttributedObservations passed to StateTransition
//
// - a query or observation is malformed. (For defense in depth, it is also
// recommended that malformed outcomes are handled gracefully.)
//
// - instances of the ReportingPlugin run by different oracles have different
// call traces. E.g., the ReportingPlugin's Observation function may have been
// invoked on node A, but not on node B.
//
// All functions on an ReportingPlugin should be thread-safe.
//
// The execution of the functions in the ReportingPlugin is on the critical path
// of the protocol's execution. A blocking function may block the oracle from
// participating in the protocol. Functions should be designed to generally
// return as quickly as possible and honor context expiration. Context
// expiration may occur for a number of reasons, including (1) shutdown of the
// protocol instance, (2) the protocol's progression through epochs (whether
// they're abandoned or completed successfully), and (3) timeout parameters. See
// the documentation on ocr3config.PublicConfig for more information on how
// to configure timeouts.
//
// For a given OCR protocol instance, there can be many (consecutive) instances
// of an ReportingPlugin, e.g. due to software restarts. If you need
// ReportingPlugin state to survive across restarts, you should
// persist it in the key-value store. A ReportingPlugin instance will only ever serve a
// single protocol instance. State is not preserved between protocol instances.
// A fresh protocol instance will start with a clean state.
// Carrying state between different protocol instances is up to the
// ReportingPlugin logic.
type ReportingPlugin[RI any] interface {
	// Query creates a Query that is sent from the leader to all follower nodes
	// as part of the request for an observation. Be careful! A malicious leader
	// could equivocate (i.e. send different queries to different followers.)
	// Many applications will likely be better off always using an empty query
	// if the oracles don't need to coordinate on what to observe (e.g. in case
	// of a price feed) or the underlying data source offers an (eventually)
	// consistent view to different oracles (e.g. in case of observing a
	// blockchain).
	//
	// You may assume that the seqNr is increasing strictly monotonically
	// across the lifetime of a protocol instance.
	//
	// The KeyValueReader gives read access to the key-value store in the state
	// that it is after seqNr - 1 is committed.
	Query(ctx context.Context, seqNr uint64, keyValueReader KeyValueReader, blobBroadcastFetcher BlobBroadcastFetcher) (types.Query, error)

	// Observation gets an observation from the underlying data source. Returns
	// a value or an error.
	//
	// You may assume that the seqNr is increasing strictly monotonically
	// across the lifetime of a protocol instance.
	//
	// The KeyValueReader gives read access to the key-value store in the state
	// that it is after seqNr - 1 is committed.
	Observation(ctx context.Context, seqNr uint64, aq types.AttributedQuery, keyValueReader KeyValueReader, blobBroadcastFetcher BlobBroadcastFetcher) (types.Observation, error)

	// ValidateObservation should return an error if an observation isn't well-formed.
	// Non-well-formed  observations will be discarded by the protocol. This
	// function should be pure. This is called for each observation, don't do
	// anything slow in here.
	//
	// You may assume that the seqNr is increasing strictly monotonically
	// across the lifetime of a protocol instance.
	//
	// The KeyValueReader gives read access to the key-value store in the state
	// that it is after seqNr - 1 is committed.
	ValidateObservation(ctx context.Context, seqNr uint64, aq types.AttributedQuery, ao types.AttributedObservation, keyValueReader KeyValueReader, blobFetcher BlobFetcher) error

	// ObservationQuorum indicates whether the provided valid (according to
	// ValidateObservation) observations are sufficient to construct an outcome.
	//
	// This function should be pure. Don't do anything slow in here.
	//
	// This is an advanced feature. The "default" approach (what OCR1 & OCR2
	// did) is to have this function call
	// quorumhelper.ObservationCountReachesObservationQuorum(QuorumTwoFPlusOne, ...)
	//
	// If you write a custom implementation, be sure to consider that Byzantine
	// oracles may not contribute valid observations, and you still want your
	// plugin to remain live. This function must be monotone in aos, i.e. if
	// it returns true for aos, it must also return true for any
	// superset of aos.
	//
	// The KeyValueReader gives read access to the key-value store in the state
	// that it is after seqNr - 1 is committed.
	ObservationQuorum(ctx context.Context, seqNr uint64, aq types.AttributedQuery, aos []types.AttributedObservation, keyValueReader KeyValueReader, blobFetcher BlobFetcher) (quorumReached bool, err error)

	// StateTransition modifies the state of the Reporting Plugin, based on
	// the attributed query and the set of attributed observations of the round.
	// Generates ReportsPlusPrecursor, which encodes a possibly empty list of
	// reports, as a side effect.
	//
	// This function should be pure. Don't do anything slow in here.
	//
	//
	// You may assume that the seqNr is increasing strictly monotonically
	// across the lifetime of a protocol instance.
	//
	// You may assume that the provided list of attributed observations has been
	// (1) validated by ValidateObservation on each element, and (2) checked
	// by ObservationQuorum to have reached quorum.
	//
	// The KeyValueReadWriter gives read and write access to the key-value store in the state
	// that it is after seqNr - 1 is committed.
	StateTransition(ctx context.Context, seqNr uint64, aq types.AttributedQuery, aos []types.AttributedObservation, keyValueReadWriter KeyValueReadWriter, blobFetcher BlobFetcher) (ReportsPlusPrecursor, error)

	// Committed notifies the plugin that a sequence number has been committed.
	// It might or might not be preceded by a StateTransition call for the same
	// sequence number.
	// TODO: This function is not called by the protocol yet.
	Committed(ctx context.Context, seqNr uint64, keyValueReader KeyValueReader) error

	// Reports generates a (possibly empty) list of reports from a ReportsPlusPrecursor. Each report
	// will be signed and possibly be transmitted to the contract. (Depending on
	// ShouldAcceptAttestedReport & ShouldTransmitAcceptedReport)
	//
	// This function should be pure. Don't do anything slow in here.
	//
	// This is likely to change in the future. It will likely be returning a
	// list of report batches, where each batch goes into its own Merkle tree.
	Reports(ctx context.Context, seqNr uint64, reportsPlusPrecursor ReportsPlusPrecursor) ([]ocr3types.ReportPlus[RI], error)

	// ShouldAcceptAttestedReport decides whether a report should be accepted for transmission.
	// Any report passed to this function will have been attested, i.e. signed by f+1
	// oracles.
	//
	// Don't make assumptions about the seqNr order in which this function
	// is called.
	ShouldAcceptAttestedReport(ctx context.Context, seqNr uint64, reportWithInfo ocr3types.ReportWithInfo[RI]) (bool, error)

	// ShouldTransmitAcceptedReport decides whether the given report should actually
	// be broadcast to the contract. This is invoked just before the broadcast occurs.
	// Any report passed to this function will have been signed by a quorum of oracle
	// and been accepted by ShouldAcceptAttestedReport.
	//
	// Don't make assumptions about the seqNr order in which this function
	// is called.
	//
	// As mentioned above, you should gracefully handle only a subset of a
	// ReportingPlugin's functions being invoked for a given report. For
	// example, due to reloading persisted pending transmissions from the
	// database upon oracle restart, this function  may be called with reports
	// that no other function of this instance of this interface has ever
	// been invoked on.
	ShouldTransmitAcceptedReport(ctx context.Context, seqNr uint64, reportWithInfo ocr3types.ReportWithInfo[RI]) (bool, error)

	// If Close is called a second time, it may return an error but must not
	// panic. This will always be called when a plugin is no longer
	// needed, e.g. on shutdown of the protocol instance or shutdown of the
	// oracle node. This will only be called after any calls to other functions
	// of the plugin have completed.
	Close() error
}

// It's much easier to increase these than to decrease them, so we start with
// conservative values. Talk to the maintainers if you need higher limits for
// your plugin.
const (
	mib = 1024 * 1024

	MaxMaxQueryLength                = mib / 2
	MaxMaxObservationLength          = mib / 2
	MaxMaxReportsPlusPrecursorLength = 5 * mib
	MaxMaxReportLength               = 5 * mib
	MaxMaxReportCount                = 2000

	MaxMaxKeyValueKeyLength   = 1 * mib
	MaxMaxKeyValueValueLength = 2 * mib

	MaxMaxKeyValueModifiedKeysPlusValuesLength = 10 * mib

	MaxMaxBlobPayloadLength = 5 * mib
)

// Limits for data returned by the ReportingPlugin.
// Used for computing rate limits and defending against outsized messages.
// Messages are checked against these values during (de)serialization. Be
// careful when changing these values, they could lead to different versions
// of a ReportingPlugin being unable to communicate with each other.
type ReportingPluginLimits struct {
	MaxQueryLength                int
	MaxObservationLength          int
	MaxReportsPlusPrecursorLength int
	MaxReportLength               int
	MaxReportCount                int

	// This limit concerns modifications to key-values inside the
	// StateTransition method. Write(k, v) and Delete(k) count as modifications.
	// A modification that resets the value of a key to its original value at
	// the start of StateTransition will still count towards the limit.
	MaxKeyValueModifiedKeysPlusValuesLength int

	MaxBlobPayloadLength int

	// Mandatory blob rate limits will be introduced in a future release.
}

type ReportingPluginInfo struct {
	// Used for debugging purposes.
	Name string

	Limits ReportingPluginLimits
}
